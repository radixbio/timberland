job "minio-job" {
  namespace = "${namespace}"
  all_at_once = false

  constraint {
    attribute = "$${attr.kernel.name}"
    operator = "="
    value = "linux"
  }

  datacenters = ["dc1"]
${ !have_upstream_creds ? "" : <<EOH
  group minio-remote-group {
    count = 1
    task "minio-remote" {
      vault {
        policies = ["read-flag-config"]
        change_mode = "signal"
        change_signal = "SIGUSR1"
      }

      config {
        image = "minio/minio:latest"
        args = ["gateway", "s3"]
        auth_soft_fail = false
        entrypoint = ["minio"]
        privileged = false
        volumes = ["/opt/radix/minio_data_remote:/data"]
        cap_add = []
      }

      driver = "docker"
      env = {
        "MINIO_ACCESS_KEY" = "${have_upstream_creds ? aws_access_key : ""}", # this may cause an error
        "MINIO_SECRET_KEY" = "${have_upstream_creds ? aws_secret_key : ""}"
      }

      kill_timeout = "5s"
      kill_signal = "SIGINT"
      leader = false

      resources {
        cpu = 1000
        memory = 300
      }

      shutdown_delay = "0s"
    }

    network {
      mbits = 10
      mode = "bridge"
    }

    service {
      name = "minio-remote-service"
      port = 9000
      tags = ["minio", "remote", "user"]
      address_mode = "auto"

      connect {
        sidecar_service {
          proxy {
            upstreams {
              destination_name = "kafka-0"
              local_bind_port = 9092
            }
          }
        }
      }
# sometimes with works on either ubuntu or centos and may or may not time out, perhaps depending on branch name
# it might be related to ssl/mTLS
      check {
        type = "http"
        name = "minio-remote-health"
        path = "/minio/health/live"
        interval = "30s"
        timeout = "5s"
        expose = true
      }
    }
  }
EOH
}

  group "minio-local-group" {
    count = 1

    task "minio-local" {
      vault {
        policies = ["read-flag-config"]

        change_mode = "signal"
        change_signal = "SIGUSR1"
      }

      config {
        image = "minio/minio:latest"
        auth_soft_fail = false
        privileged = false
        entrypoint = ["minio", "--compat"]
        args = ["server", "/data"]
        volumes = ["/opt/radix/minio_data:/data"]
        cap_add = []
      }

      driver = "docker"

      env = {
        "MINIO_NOTIFY_KAFKA_ENABLE" = "true",
        "MINIO_NOTIFY_KAFKA_BROKERS" = "$${NOMAD_UPSTREAM_ADDR_kafka-0}",
        "MINIO_NOTIFY_KAFKA_TOPIC" = "bucketevents",
        "MINIO_ACCESS_KEY" = "${have_upstream_creds ? aws_access_key : minio_access_key}",
        "MINIO_SECRET_KEY" = "${have_upstream_creds ? aws_secret_key : minio_secret_key}"
      }

      kill_timeout = "5s"
      kill_signal = "SIGINT"
      leader = false

      resources {
        cpu = 1000
        memory = 700
      }

      shutdown_delay = "0s"
    }

    task "nginx-minio" {

      config {
        image = "openresty/openresty:latest"
        auth_soft_fail = false
        privileged = false
        volumes = ["local/nginx.conf:/etc/openresty/nginx.conf"]
        cap_add = []
      }

      template {
        change_mode = "noop"
        destination = "local/nginx.conf"

        data = <<EOH
        worker_processes 1;

        events {
          worker_connections 1024;
        }

        http {
          default_type text/html;
          access_log /dev/stdout;
          sendfile on;
          keepalive_timeout 65;

          upstream minio {
            server 127.0.0.1:9000;
            server 127.0.0.1:9001 backup;
          }

          %{ if have_upstream_creds }
          map $http_authorization $authorization {
            default $http_authorization;
            ~${minio_access_key} "${aws_access_key}";
            ~${minio_secret_key} "${aws_secret_key}";
          }
          %{ endif }

          server {
            listen 1339;
            server_name nginx-minio.service.consul;

            ignore_invalid_headers off;
            client_max_body_size 10000m;
            proxy_buffering off;

            location /health {
                return 200;
            }

            location / {
              proxy_set_header X-Real-IP $remote_addr;
              proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
              proxy_set_header X-Forwarded-Proto $scheme;
              proxy_set_header Host $http_host;
              proxy_set_header Authorization ${ have_upstream_creds ? "$authorization" : "$http_authorization"};
              proxy_hide_header "X-AMZ-Bucket-Region";
              proxy_hide_header "X-AMZ-Request-Id";

              proxy_connect_timeout 300;
              # Default is HTTP/1, keepalive is only enabled in HTTP/1.1
              proxy_http_version 1.1;
              proxy_set_header Connection "";
              chunked_transfer_encoding off;

              %{ if have_upstream_creds }
              if ($request_method = POST) {
                access_by_lua_block {
                  if ngx.var.uri == '/minio/webrpc' then
                    ngx.req.read_body()
                    local req = ngx.req.get_body_data()
                    local new_req, n, err = ngx.re.gsub(req, "${minio_access_key}", "${aws_access_key}")
                    local newer_req, n_, err_ = ngx.re.gsub(new_req, "${minio_secret_key}", "${aws_secret_key}")
                    ngx.req.set_body_data(newer_req)
                  end
                }
              }
              %{ endif }

              proxy_pass http://minio;
              ${ have_upstream_creds ? "proxy_next_upstream error http_404;" : "" }
            }
          }
        }
        EOH
      }

      restart {
        attempts = 10
        delay = "20s"
        mode = "fail"
      }

      driver = "docker"
      kill_timeout = "5s"
      kill_signal = "SIGINT"
      leader = false

      resources {
        cpu = 1000
        memory = 300
      }

      shutdown_delay = "0s"
    }

    network {
      mbits = 10
      mode = "bridge"
      port "nginx" {
        static = 1339
        to = 1339
      }
      port "minio_local" {
        to = 9000
        static = 9000
      }
    }

    service {
      name = "nginx-minio"
      port = "nginx"
      tags = ["minio", "client", "user"]
      address_mode = "host"

      connect {
        sidecar_service {
          proxy {
            upstreams {
              destination_name = "minio-remote-service"
              local_bind_port = 9001
            }
          }
        }
      }

      check {
        type = "http"
        name = "nginx-minio-health"
        path = "/minio/health/live"
        interval = "30s"
        timeout = "5s"
        expose = true
      }
    }

    service {
      name = "minio-local-service"
      port = 9000
      tags = ["minio", "local", "user"]
      address_mode = "auto"

      connect {
        sidecar_service {
          proxy {
            upstreams {
              destination_name = "kafka-0"
              local_bind_port = 9092
            }
          }
        }
      }

      check {
        type = "http"
        name = "minio-local-health"
        path = "/minio/health/live"
        interval = "30s"
        timeout = "5s"
        expose = true
      }
    }
  }

  priority = 50
  region = "global"
  type = "service"

  update {
    max_parallel = 1
    health_check = "checks"
    min_healthy_time = "10s"
    healthy_deadline = "5m"
    progress_deadline = "10m"
    auto_revert = false
    canary = 0
    stagger = "10s"
  }
}
