job "${prefix}minio-job" {
  all_at_once = false

  constraint {
    attribute = "$${attr.kernel.name}"
    operator = "="
    value = "linux"
  }

  datacenters = ["dc1"]

  group "minio-group" {
    count = 1

    task "minio-local" {
      vault {
        policies = ["read-flag-config"]
        change_mode = "signal"
        change_signal = "SIGUSR1"
      }

      template {
        data = <<EOF
      {{with secret "secret/data/flag-config"}}
      {{ if .Data.data.minio.aws_access_key_id}}
            MINIO_ACCESS_KEY = "{{.Data.data.minio.aws_access_key_id}}"
      {{else}}
      	    MINIO_ACCESS_KEY = "minio-access-key"
      {{end}}
      {{end}}
      {{with secret "secret/data/flag-config"}}
      {{ if .Data.data.minio.aws_secret_access_key}}
            MINIO_SECRET_KEY = "{{.Data.data.minio.aws_secret_access_key}}"
      {{else}}
            MINIO_SECRET_KEY = "minio-secret-key"
      {{end}}
      {{end}}
    EOF
        destination = "secrets/file.env"
        env = true
      }

      config {
        image = "minio/minio:latest"
        auth_soft_fail = false
        hostname = "$${attr.unique.hostname}-em"
        privileged = false
        network_mode = "weave"
        port_map = {
          "minio" = 9000
        }
        entrypoint = ["minio", "--compat"]
        args = ["server", "/data"]
        volumes = ["/opt/radix/minio_data:/data"]
        cap_add = []
      }

      driver = "docker"

      env = {
        "MINIO_NOTIFY_KAFKA_ENABLE" = "true",
        "MINIO_NOTIFY_KAFKA_BROKERS" = "${prefix}kafka-daemons-kafka-kafka.service.consul:29092",
        "MINIO_NOTIFY_KAFKA_TOPIC" = "bucketevents"
      }

      kill_timeout = "5s"
      kill_signal = "SIGINT"
      leader = false

      resources {
        cpu = 1000
        memory = 300

        network {
          mbits = 10

          port "minio" {
            static = 9000
          }
        }
      }

      service {
        port = "minio"
        tags = ["minio", "client"]
        address_mode = "auto"

        check {
          address_mode = "host"
          grpc_use_tls = true
          initial_status = "critical"
          interval = "10s"
          method = "GET"
          port = "minio"
          protocol = "http"
          timeout = "2s"
          type = "tcp"
          tls_skip_verify = false
        }
      }

      shutdown_delay = "0s"
    }

    ${ !have_upstream_creds ? "" : <<-EOH
    task "minio-remote" {
      vault {
        policies = ["read-flag-config"]
        change_mode = "signal"
        change_signal = "SIGUSR1"
      }

      config {
        image = "minio/minio:latest"
        args = ["gateway", "s3"]
        auth_soft_fail = false
        entrypoint = ["minio"]
        hostname = "$${attr.unique.hostname}-em"
        privileged = false
        network_mode = "weave"
        port_map = {
          "minio_remote" = 9000
        }
        volumes = ["/opt/radix/minio_data_remote:/data"]
        cap_add = []
      }

      driver = "docker"
      template {
        data = <<EOF
      {{with secret "secret/data/flag-config"}}
      {{ if .Data.data.minio.aws_access_key_id}}
            MINIO_ACCESS_KEY = "{{.Data.data.minio.aws_access_key_id}}"
      {{else}}
      	     MINIO_ACCESS_KEY = "minio-access-key"
      {{end}}
      {{end}}
      {{with secret "secret/data/flag-config"}}
      {{ if .Data.data.minio.aws_secret_access_key}}
            MINIO_SECRET_KEY = "{{.Data.data.minio.aws_secret_access_key}}"
      {{else}}
            MINIO_SECRET_KEY = "minio-secret-key"
      {{end}}
      {{end}}
    EOF
        destination = "secrets/file.env"
        env = true
      }

      kill_timeout = "5s"
      kill_signal = "SIGINT"
      leader = false

      resources {
        cpu = 1000
        memory = 300

        network {
          mbits = 10

          port "minio_remote" {
            static = 9002
          }
        }
      }

      service {
        port = "minio_remote"
        tags = ["minio", "client"]
        address_mode = "auto"

        check {
          address_mode = "host"
          grpc_use_tls = true
          initial_status = "critical"
          interval = "10s"
          method = "GET"
          port = "minio_remote"
          protocol = "http"
          timeout = "2s"
          type = "tcp"
          tls_skip_verify = false
        }
      }

      shutdown_delay = "0s"
    }
        EOH
    }

    task "nginx-minio" {

      config {
        image = "nginx:latest"
        auth_soft_fail = false
        hostname = "$${attr.unique.hostname}-em"
        privileged = false
        network_mode = "weave"
        volumes = ["local/nginx.conf:/etc/nginx/nginx.conf"]
        port_map = {
          "nginx" = 9000
        }
        cap_add = []
      }

      template {
        change_mode = "noop"
        destination = "local/nginx.conf"

        data = <<EOH
        worker_processes 1;

        events {
          worker_connections 1024;
        }

        http {
          default_type text/html;
          access_log /dev/stdout;
          sendfile on;
          keepalive_timeout 65;

          upstream minio {
            {{ range service "${prefix}minio-job-minio-group-minio-local" }}
              server {{ .Address }}:{{ .Port }};
            {{ end }}

            {{ range service "${prefix}minio-job-minio-group-minio-remote" }}
              server {{ .Address }}:{{ .Port }} backup;
            {{ end }}
          }

          server {
            listen 9000;
            server_name ${prefix}minio-job-minio-group-nginx-minio.service.consul;

            ignore_invalid_headers off;
            client_max_body_size 10000m;
            proxy_buffering off;

            location / {
              proxy_set_header X-Real-IP $remote_addr;
              proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
              proxy_set_header X-Forwarded-Proto $scheme;
              proxy_set_header Host $http_host;
              proxy_hide_header "X-AMZ-Bucket-Region";
              proxy_hide_header "X-AMZ-Request-Id";

              proxy_connect_timeout 300;
              # Default is HTTP/1, keepalive is only enabled in HTTP/1.1
              proxy_http_version 1.1;
              proxy_set_header Connection "";
              chunked_transfer_encoding off;

              proxy_pass http://minio;
              ${ have_upstream_creds ? "proxy_next_upstream error http_404;" : "" }
            }
          }
        }
        EOH
      }

      restart {
        attempts = 10
        delay = "20s"
        mode = "fail"
      }

      driver = "docker"
      kill_timeout = "5s"
      kill_signal = "SIGINT"
      leader = false

      resources {
        cpu = 1000
        memory = 300

        network {
          mbits = 10

          port "nginx" {
            static = 1339
          }
        }
      }

      service {
        port = "nginx"
        tags = ["minio", "client"]
        address_mode = "host"

        check {
          address_mode = "host"
          grpc_use_tls = true
          initial_status = "critical"
          interval = "10s"
          method = "GET"
          port = "nginx"
          protocol = "http"
          timeout = "2s"
          type = "tcp"
          tls_skip_verify = false
        }
      }

      shutdown_delay = "0s"
    }
  }

  namespace = "default"
  priority = 50
  region = "global"
  type = "service"

  update {
    max_parallel = 1
    health_check = "checks"
    min_healthy_time = "10s"
    healthy_deadline = "5m"
    progress_deadline = "10m"
    auto_revert = false
    canary = 0
    stagger = "10s"
  }
}
